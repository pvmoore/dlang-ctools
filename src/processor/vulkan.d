module processor.vulkan;

import processor.base;

final class VulkanProcessor : Processor {
private:
    EConfig config;
    Extractor extractor;
    Emitter emitter;
    enum vulkanVersion = "1.4.321.1";
public:
    override void process() {
        prepare();

        string vulkanSdk = environment.get("VULKAN_SDK");
        string vulkanH = vulkanSdk ~ "/Include/vulkan/vulkan.h";

        parse(Filepath(vulkanH));
        extract();
    	emit();
    }
protected:
    override void adjustDefines(ref string[string] defines) {
        defines["VK_USE_PLATFORM_WIN32_KHR"] = "1";
    }
    override void adjustIncludes(ref string[] includeDirs) {
        string vulkanSdk = environment.get("VULKAN_SDK");
        includeDirs ~= vulkanSdk ~ "/Include";
    }
private:
    void extract() {

        convertVkFlags2ToEnums();

        this.config = new EConfig();

        config.requiredFunctionRegexes ~= [
            regex(r"^vk.*$")];
        config.requiredTypeRegexes ~= [
            regex(r"^Vk.*$"),
            regex(r"^Std.*")
        ];
        config.requiredTypedefRegexes ~= regex(r"^(PFN_vk|Vk).*$");

        config.excludeRegexes ~= [
            regex(r"^(HINSTANCE|HMONITOR|HWND)$"),
            regex(r".*(__security_cookie|GUID).*")
        ];

        this.extractor = new Extractor(config);
        extractor.process(parent);
    }
    void emit() {
        enum string[] COMMENTS = [
            "Vulkan %s Include files converted to D (This is a generated file)".format(vulkanVersion),
            "",
            "Generated by CTools (https://github.com/pvmoore/dlang-CTools)",
            "",
            "Usage:",
            "  ** Start program",
            "  VulkanLoader.load();",
            "  vkLoadGlobalCommandFunctions();",
            "  ** Create your VkInstance here",
            "  vkLoadInstanceFunctions(instance);",
            "  ** ",
            "  VulkanLoader.unload();",
            "  ** Exit program"
        ];

        auto flags = Emitter.Flag.UNQUALIFIED_ENUM | Emitter.Flag.QUALIFIED_ENUM;

        auto extraDefs = [
            "VK_NULL_HANDLE" : "null",
            "VK_TRUE" : "1",
            "VK_FALSE" : "0",
            "VK_QUEUE_FAMILY_IGNORED" : "(~0U)",
            "VK_REMAINING_MIP_LEVELS" : "(~0U)",
            "VK_REMAINING_ARRAY_LAYERS" : "(~0U)",
            "VK_SUBPASS_EXTERNAL" : "(~0U)",
            "VK_WHOLE_SIZE" : "(~0UL)",
            "VK_SHADER_UNUSED_KHR" : "(~0U)"
        ];
        string[string] extraAliases;

        auto funcDecls = getOrderedValues(extractor.funcDecls);

        writefln("emitting...");

        this.emitter = new Emitter(extractor, "vulkan_api", flags)
            .privateImports(["core.sys.windows.windows"])
            .extraDefinitions(extraDefs)
            .extraAliases(extraAliases);

        emitter.add(new Comment(COMMENTS));

        emitter.add(new EmitDLLLoader("VulkanLoader", "vulkan-1.dll")
                        .loadFunctions("vkGetInstanceProcAddr"));

        emitter.add(new LoadGlobalCommandFunctions(funcDecls));
        emitter.add(new LoadInstanceFunctions(funcDecls));

        emitter.emitTo("generated/vulkan_api.d");
    }

    
    void convertVkFlags2ToEnums() {
        Var[][string] vars; 

        foreach(v; parent.range().filter!(it=>it.isA!Var).map!(it=>it.as!Var).filter!(it=>it.type().isConst)) {

            if(TypeRef tr = v.type.as!TypeRef) {
                if(TypeRef tr2 = tr.type.as!TypeRef) {
                    if(tr2.name == "VkFlags64") {
                        vars.update(tr.name, ()=>[v], (ref Var[] list) { list ~= v;});
                    }
                }
            }
        }

        foreach(e; vars.byKeyValue) {
            writefln("%s:", e.key);
            foreach(v; e.value) {
                v.detach();
            }
        }
        foreach(e; vars.byKeyValue) {
            auto en = new Enum(e.key);
            parent.add(en);
            foreach(v; e.value) {
                auto id = new Identifier(v.name);
                auto expr = v.initialiser();
                id.add(expr);
                en.add(id);
            }
        }

        TypeRef[] toBeRemoved;

        foreach(tr; parent.range().filter!(it=>it.isA!TypeRef).map!(it=>it.as!TypeRef)) {
            if(tr.name in vars) {
                writefln("Removing %s", tr);
                toBeRemoved ~= tr;
            }
        }

        foreach(tr; toBeRemoved) {
            tr.detach();
        }
    }
}
private:

__gshared string[] GLOBAL_CMD_FUNCS = [
    "vkEnumerateInstanceVersion",
    "vkEnumerateInstanceExtensionProperties",
    "vkEnumerateInstanceLayerProperties",
    "vkCreateInstance",
];

class LoadGlobalCommandFunctions : Emitter.AppenderPlugin {
protected:
    FuncDecl[] funcDecls;
public:
    this(FuncDecl[] funcDecls) {
        this.funcDecls = funcDecls;
    }
    bool accept(FuncDecl fd) {
        return fd.name.isOneOf(GLOBAL_CMD_FUNCS);
    }
    override void emit(StringBuffer buf) {
        prolog(buf);
        foreach(fd; funcDecls) {
            if(accept(fd)) {
                load(buf, fd);
            }
        }
        epilog(buf);
    }
    void prolog(StringBuffer buf) {
        buf.add("// Load Global Command Functions\n");
        buf.add("void vkLoadGlobalCommandFunctions() {\n");
        buf.add("\timport std.string : toStringz;\n");
        buf.add("\timport common.utils : throwIf;\n");
    }
    void epilog(StringBuffer buf) {
        buf.add("}\n");
    }
    void load(StringBuffer buf, FuncDecl fd) {
        buf.add("\t*(cast(void**)&%s) = vkGetInstanceProcAddr(null, toStringz(\"%s\"));", fd.name, fd.name);
        buf.add(" throwIf(!%s);\n", fd.name);
    }
}

final class LoadInstanceFunctions : LoadGlobalCommandFunctions {
private:
public:
    this(FuncDecl[] funcDecls) {
        super(funcDecls);
    }
    override bool accept(FuncDecl fd) {
        return !fd.name.isOneOf(GLOBAL_CMD_FUNCS) &&
            fd.name!="vkGetInstanceProcAddr" &&
            !fd.name.startsWith("PFN_");
    }
protected:
    override void prolog(StringBuffer buf) {
        buf.add("// Load Instance Functions\n");
        buf.add("void vkLoadInstanceFunctions(VkInstance instance) {\n");
        buf.add("\timport std.string : toStringz;\n");
        buf.add("\timport common.utils : throwIf;\n");
    }
    override void load(StringBuffer buf, FuncDecl fd) {
        buf.add("\t*(cast(void**)&%s) = vkGetInstanceProcAddr(instance, toStringz(\"%s\"));\n", fd.name, fd.name);
    }
}
