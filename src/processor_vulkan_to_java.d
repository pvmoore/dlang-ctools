module processor_vulkan_to_java;


import processor_common;

final class VulkanToJavaProcessor : Processor {
private:
    EConfig config;
    Extractor extractor;
    JavaEmitter emitter;
    enum vulkanVersion = "1.3.231.1";
public:
    void process() {
        prepare();

        string vulkanSdk = environment.get("VULKAN_SDK");
        string vulkanH = vulkanSdk ~ "/Include/vulkan/vulkan.h";

        parse(Filepath(vulkanH));
        extract();
    	emit();
    }
protected:
    override void adjustDefines(ref string[string] defines) {
        defines["VK_USE_PLATFORM_WIN32_KHR"] = "1";
    }
    override void adjustIncludes(ref string[] includeDirs) {

    }
private:
    void extract() {
        this.config = new EConfig();

        config.requiredFunctionRegexes ~= [
            regex(r"^vk.*$")];
        config.requiredTypeRegexes ~= [
            regex(r"^Vk.*$")
        ];
        config.requiredTypedefRegexes ~= regex(r"^PFN_vk.*$");

        config.excludeRegexes ~= [
            regex(r"^(HINSTANCE|HMONITOR|HWND)$")
        ];

        this.extractor = new Extractor(config);
        extractor.process(parent);
    }
    void emit() {
        enum string[] COMMENTS = [
            "Vulkan %s Include files converted to D (This is a generated file)".format(vulkanVersion),
            "",
            "Generated by CTools (https://github.com/pvmoore/dlang-CTools)",
            "",
            "Usage:",
            "  ** Start program",
            "  VulkanLoader.load();",
            "  vkLoadGlobalCommandFunctions();",
            "  ** Create your VkInstance here",
            "  vkLoadInstanceFunctions(instance);",
            "  ** ",
            "  VulkanLoader.unload();",
            "  ** Exit program"
        ];

        writefln("Emitting...");

        auto funcDecls = getOrderedValues(extractor.funcDecls);

        this.emitter = new JavaEmitter(extractor,
            "pvmoore.jvulkan",
            "C:/pvmoore/JVM/libs/jVulkan/src/main/java/pvmoore/jvulkan/",
            "C:/pvmoore/JVM/libs/jVulkan/src/main/java/pvmoore/jvulkan/structstemp/");

        emitter.withCallback(new VulkanToJavaCallback(emitter, vulkanVersion));

        emitter.emit();

        //     .extraDefinitions(extraDefs);

        // emitter.add(new Comment(COMMENTS));

        // emitter.add(new EmitDLLLoader("VulkanLoader", "vulkan-1.dll")
        //                 .loadFunctions("vkGetInstanceProcAddr"));

        // emitter.add(new LoadGlobalCommandFunctions(funcDecls));
        // emitter.add(new LoadInstanceFunctions(funcDecls));

        // emitter.emitTo("generated/vulkan_api.d");
    }
}
//══════════════════════════════════════════════════════════════════════════════════════════════════
private:

__gshared string[] GLOBAL_CMD_FUNCS = [
    "vkEnumerateInstanceVersion",
    "vkEnumerateInstanceExtensionProperties",
    "vkEnumerateInstanceLayerProperties",
    "vkCreateInstance",
];
//──────────────────────────────────────────────────────────────────────────────────────────────────
class LoadGlobalCommandFunctions : Emitter.AppenderPlugin {
protected:
    string packageName;
    FuncDecl[] funcDecls;
public:
    this(string packageName, FuncDecl[] funcDecls) {
        this.packageName = packageName;
        this.funcDecls = funcDecls;
    }
    bool accept(FuncDecl fd) {
        return fd.name.isOneOf(GLOBAL_CMD_FUNCS);
    }
    override void emit(StringBuffer buf) {
        prolog(buf);
        foreach(fd; funcDecls) {
            if(accept(fd)) {
                load(buf, fd);
            }
        }
        epilog(buf);
    }
    void prolog(StringBuffer buf) {
        buf.add("package %s", packageName);
        buf.add("public final class FunctionLoader {\n");
        buf.add("\tpublic void vkLoadGlobalCommandFunctions() {\n");
        buf.add("");
    }
    void epilog(StringBuffer buf) {
        buf.add("}\n");
    }
    void load(StringBuffer buf, FuncDecl fd) {
        buf.add("\t*(cast(void**)&%s) = vkGetInstanceProcAddr(null, toStringz(\"%s\"));", fd.name, fd.name);
        buf.add(" throwIf(!%s);\n", fd.name);
    }
}
//──────────────────────────────────────────────────────────────────────────────────────────────────
final class LoadInstanceFunctions : Emitter.AppenderPlugin {
private:
    string packageName;
    FuncDecl[] funcDecls;
public:
    this(string packageName, FuncDecl[] funcDecls) {
        this.packageName = packageName;
        this.funcDecls = funcDecls;
    }
    bool accept(FuncDecl fd) {
        return !fd.name.isOneOf(GLOBAL_CMD_FUNCS) &&
            fd.name!="vkGetInstanceProcAddr" &&
            !fd.name.startsWith("PFN_");
    }
    override void emit(StringBuffer buf) {
        prolog(buf);
        foreach(fd; funcDecls) {
            if(accept(fd)) {
                load(buf, fd);
            }
        }
        epilog(buf);
    }
protected:
    void prolog(StringBuffer buf) {
        buf.add("package %s", packageName);
        buf.add("public final class FunctionLoader {\n");
        buf.add("\tpublic void vkLoadInstanceFunctions(VkInstance instance) {\n");
    }
    void load(StringBuffer buf, FuncDecl fd) {
        //buf.add("\t*(cast(void**)&%s) = vkGetInstanceProcAddr(instance, toStringz(\"%s\"));", fd.name, fd.name);
        buf.add("\t// load %s\n", fd.name);
    }
    void epilog(StringBuffer buf) {
        buf.add("}\n");
    }
}
//══════════════════════════════════════════════════════════════════════════════════════════════════
final class VulkanToJavaCallback : JavaEmitter.Callback {
private:
    JavaEmitter emitter;
    string vulkanVersion;
    StringBuffer buf;
public:
    this(JavaEmitter emitter, string vulkanVersion) {
        this.emitter = emitter;
        this.vulkanVersion = vulkanVersion;
        this.buf = new StringBuffer();
    }
    void begin() {
        buf.add("package pvmoore.jvulkan;\n\n");
        buf.add("/**\n");
        buf.add(" * This file was generated from Vulkan SDK version %s\n", vulkanVersion);
        buf.add(" */\n");
        buf.add("public final class Enums {\n");
    }
    void end() {
        buf.add("}\n");

        auto file = File("C:/pvmoore/JVM/libs/jVulkan/src/main/java/pvmoore/jvulkan/Enums.java", "wb");
        file.writef(buf.toString());
        file.close();

        writefln("counter = %s", counter);
    }
    void structDef(StructDef sd) {
        commonStructOrUnion(sd, null);
    }
    void union_(Union u) {
        commonStructOrUnion(null, u);
    }
    void func(FuncDecl fd) {
        if(fd.name.isOneOf(GLOBAL_CMD_FUNCS) || fd.name=="vkGetInstanceProcAddr" || fd.name.startsWith("PFN_")) {
            return;
        }

        // TODO - write the function loaders here
    }
    void enum_(Enum e) {
        foreach(id; e.getIdentifiers()) {
            assert(id.hasChildren());

            if(id.first().isA!Identifier) continue;

            buf.add("\tpublic static final int %s = ", id.name);
            emitter.emit(id.first(), buf);

            buf.add(";\n");
        }
        buf.add("\n");
    }
private:
    void commonStructOrUnion(StructDef sdef, Union un) {
        string name;
        Var[] vars;
        bool hassTypeAndpNext;
        bool isUnion;

        if(sdef) {
            name = sdef.name;
            vars = sdef.variables();
            hassTypeAndpNext = sdef.hasVariable("sType") && sdef.hasVariable("pNext") &&
                               sdef.name!="VkBaseInStructure" && sdef.name!="VkBaseOutStructure";
        } else {
            isUnion = true;
            name = un.name;
            vars = un.vars();
        }

        if(name.isOneOf("_SECURITY_ATTRIBUTES", "HINSTANCE__", "HMONITOR__", "HWND__")) return;

        auto buf = new StringBuffer();

        buf.add("package pvmoore.jvulkan.structs;\n\n");

        buf.add("import static pvmoore.jvulkan.Enums.*;\n");
        buf.add("import java.lang.foreign.*;\n");
        buf.add("import static java.lang.foreign.ValueLayout.*;\n");
        //buf.add("import pvmoore.jvulkan.structs.Struct;\n");
        buf.add("import static pvmoore.jvulkan.misc.Util.throwIf;\n\n");

        if(isUnion) {
            buf.add("// This Struct is actually a Union\n");
        }

        buf.add("public final class %s extends Struct {\n", name);

        // Write the member variables as a comment
        int offset = 0;
        foreach(v; vars) {
            auto n = v.name;
            auto t = v.type();

            buf.add("\t// [%0.2s] ", offset);
            emitter.emit(t, buf);
            buf.add(" %s\n", n);

            if(!isUnion) {
                offset += size(t);
            }
        }

        // LAYOUT
        if(isUnion) {
            buf.add("\tpublic static final MemoryLayout LAYOUT = MemoryLayout.unionLayout(");
        } else {
            buf.add("\tpublic static final MemoryLayout LAYOUT = MemoryLayout.structLayout(");
        }
        if(vars.length > 0) {
            buf.add("\n");
        }
        foreach(i, v; vars) {
            auto n = v.name;
            auto t = v.type();

            buf.add("\t\t" ~ getJavaLayout(t));

            if(i < vars.length-1) {
                buf.add(",\n");
            }
        }
        buf.add(");\n\n");

        // Constructor
        buf.add("\tprivate %s(MemorySegment mem, int count) {\n", name);
        buf.add("\t\tsuper(mem, count);\n");
        buf.add("\t}\n\n");

        // Alloc
        buf.add("\tpublic static %s alloc(MemorySession session, int count) {\n", name);
        if(hassTypeAndpNext) {
            buf.add("\t\tvar mem = count == 1 ? session.allocate(LAYOUT) : session.allocateArray(LAYOUT, count);\n");
            buf.add("\t\tvar obj = wrap(mem, count);\n");
            auto e = getStructureType(name);

            buf.add("\t\tfor(int i=0; i<count; i++) {\n");
            buf.add("\t\t\tStruct.set(mem, i*LAYOUT.byteSize(), %s);\n", e);
            buf.add("\t\t\tStruct.setNull(mem, 4 + i*LAYOUT.byteSize());\n");
            buf.add("\t\t}\n");

            buf.add("\t\treturn obj;\n");
        } else {
            buf.add("\t\treturn wrap(session.allocateArray(LAYOUT, count), count);\n");
        }
        buf.add("\t}\n");

        // Alloc
        buf.add("\tpublic static %s alloc(MemorySession session) {\n", name);
        buf.add("\t\treturn alloc(session, 1);\n");
        buf.add("\t}\n");

        // Wrap
        buf.add("\tpublic static %s wrap(MemorySegment mem, int count) {\n", name);
        buf.add("\t\treturn new %s(mem, count);\n", name);
        buf.add("\t}\n");

        // getArrayElement
        buf.add("\tpublic %s getArrayElement(int i) {\n", name);
        buf.add("\t\tthrowIf(i>=count, String.format(\"%s >= %s\", i, count));\n");
        buf.add("\t\tthis.mem = startMem.asSlice(LAYOUT.byteSize()*i);\n");
        buf.add("\t\treturn this;\n");
        buf.add("\t}\n\n");

        // Getters
        buf.add("\t// Getters\n");
        buf.add("\t@Override public MemoryLayout getLayout() {\n");
        buf.add("\t\treturn LAYOUT;\n");
        buf.add("\t}\n");
        offset = 0;
        foreach(v; vars) {
            buf.add(createGetter(name, offset, v));

            if(!isUnion) {
                offset += size(v.type());
            }
        }
        buf.add("\n");

        // Setters
        buf.add("\t// Setters\n");
        offset = 0;
        foreach(v; vars) {
            buf.add(createSetter(name, offset, v));

            if(!isUnion) {
                offset += size(v.type());
            }
        }

        if(!isUnion) {
            buf.add("\n");
            buf.add(createToString(name, vars));
        }

        buf.add("}\n");

        writeln(buf.toString());

        auto file = File("C:/pvmoore/JVM/libs/jVulkan/src/main/java/pvmoore/jvulkan/structs/" ~ name ~ ".java", "wb");
        file.writeln(buf.toString());
        file.close();
    }
}
//──────────────────────────────────────────────────────────────────────────────────────────────────
string getJavaLayout(Type t) {
    if(t.isPtr()) {
        return "ADDRESS";
    } else if(t.isA!Enum) {
        return("JAVA_INT");
    } else if(t.isA!PrimitiveType) {
        switch(t.kind) with(TKind) {
            case CHAR:
                return "JAVA_BYTE";
            case SHORT:
                return "JAVA_SHORT";
            case INT:
            case LONG:
                return "JAVA_INT";
            case LONG_LONG:
                return "JAVA_LONG";
            case FLOAT:
                return "JAVA_FLOAT";
            case DOUBLE:
                return "JAVA_DOUBLE";
            default:
                throwIf(true, "unsupported kind %s", t.kind);
                break;
        }
    } else if(auto tr = t.as!TypeRef) {
        return getJavaLayout(tr.type);
    } else if(auto ar = t.as!ArrayType) {
        import std;
        int s = ar.dimensions()
                    .map!(it=>it.as!Number)
                    .map!(it=>it.stringValue.toLower().replace("u", "").to!int)
                    .reduce!((a,b)=>a*b);

        return "MemoryLayout.sequenceLayout(%s, ".format(s) ~ getJavaLayout(ar.type()) ~ ")";

    } else if(auto sd = t.as!StructDef) {
        return sd.name ~ ".LAYOUT";
    } else if(auto u = t.as!Union) {
        return u.name ~ ".LAYOUT";
    }
    throwIf(true, "t=%s", t);
    return "?";
}
//──────────────────────────────────────────────────────────────────────────────────────────────────
string getJavaType(Type t, bool useRealStructName) {
    if(t.isA!PtrType) {
        return "Addressable";
    }
    if(t.isA!Enum) {
        return "int";
    }
    if(auto sd = t.as!StructDef) {
        return useRealStructName ? sd.name : "struct";
    }
    if(auto tr = t.as!TypeRef) {
        return getJavaType(tr.type, useRealStructName);
    }
    if(auto u = t.as!Union) {
        throwIf(!u.name, "union has no name");
        return useRealStructName ? u.name : "struct";
    }
    if(auto arr = t.as!ArrayType) {
        return getJavaType(arr.type(), useRealStructName) ~ "[]";
    }
    if(auto pt = t.as!PrimitiveType) {
        switch(t.kind) with(TKind) {
            case CHAR:
                return "byte";
            case SHORT:
                return "short";
            case INT:
            case LONG:
                return "int";
            case LONG_LONG:
                return "long";
            case FLOAT:
                return "float";
            case DOUBLE:
                return "double";
            default:
                break;
        }
    }
    throwIf(true, "Unsupported type %s", t);
    return "?";
}
//──────────────────────────────────────────────────────────────────────────────────────────────────
bool isPossibleString(string name) {
    import std;

    auto lower = name.toLower();

    if(lower.containsAny("descriptor")) return false;
    return lower.containsAny("desc", "name");
}
//──────────────────────────────────────────────────────────────────────────────────────────────────
string createGetter(string structName, int offset, Var v) {
    string s;
    auto returnJavaType = getJavaType(v.type(), true);
    auto javaType = capitalised(getJavaType(v.type(), false));
    auto array = v.type().as!ArrayType;
    bool isArray = array !is null;
    bool isPrimitiveArray = isArray && !array.type().isA!PtrType &&
        (isBuiltin(array.type()) || isEnum(array.type()));

    if(isArray) {
        javaType = javaType[0..$-2];

        if(!isPrimitiveArray && "Addressable[]"!=returnJavaType) {
            returnJavaType = returnJavaType[0..$-2];
        }
    }

    if(isArray) {
        javaType = "ArrayOf" ~ javaType;
    }

    // if("Addressable"==javaType && isPossibleString(v.name)) {
    //     auto ptr = getPtrType(v.type());
    //     throwIf(!ptr, "type = %s", v.type());

    //     if(ptr.ptrDepth == 1) {
    //         javaType = "String";
    //         returnJavaType = "String";
    //     } else if(ptr.ptrDepth == 2) {
    //         javaType = "ArrayOfString";
    //         returnJavaType = "String[]";
    //     }
    // }

    s ~= "\tpublic %s %s() {\n".format(returnJavaType, v.name);
    s ~= "\t\treturn get%s(mem, %s".format(javaType, offset);


    if("ArrayOfStruct"==javaType) {
        auto arraySize = size(array);
        auto elementSize = size(array.type());
        s ~= ", %s, %s.class)".format(arraySize / elementSize, returnJavaType);
    } else if("Struct"==javaType) {
        s ~= ", %s.class)".format(returnJavaType);
    } else if(isArray) {
        auto arraySize = size(array);
        auto elementSize = size(array.type());
        s ~= ", %s)".format(arraySize / elementSize);
    } else {
        s ~= ")";
    }

    s ~= ";\n\t}\n";

    return s;
}
string createSetter(string structName, int offset, Var v) {
    string s;
    auto javaType = getJavaType(v.type(), true);
    auto array = v.type().as!ArrayType;
    bool isArray = array !is null;
    bool isPrimitiveArray = isArray && !array.type().isA!PtrType &&
        (isBuiltin(array.type()) || isEnum(array.type()));

    // if("VkInstanceCreateInfo"==structName && offset==28) {
    //     writefln("array == %s, isPrimitiveType = %s", array, isPrimitiveArray);
    //     throwIf(true);
    // }

    if(isPrimitiveArray && array.type().kind == TKind.CHAR && isPossibleString(v.name)) {
        s ~= "\tpublic %s %s(String s) {\n".format(structName, v.name);
        s ~= "\t\tset(mem, %s, s.getBytes(), %s);\n".format(offset, size(v.type()));
        s ~= "\t\treturn this;\n";
        s ~= "\t}\n";
    }
    if("Addressable"==javaType && isPossibleString(v.name)) {
        // If we get here then v.type() must be a PtrType
        auto ptr = getPtrType(v.type());
        throwIf(!ptr, "type = %s", v.type());

        if(ptr.ptrDepth == 1) {
            s ~= "\tpublic %s %s(String s) {\n".format(structName, v.name);
            s ~= "\t\tset(mem, %s, s);\n".format(offset);
            s ~= "\t\treturn this;\n";
            s ~= "\t}\n";
        } else if(ptr.ptrDepth == 2) {
            s ~= "\tpublic %s %s(String[] s) {\n".format(structName, v.name);
            s ~= "\t\tset(mem, %s, s);\n".format(offset);
            s ~= "\t\treturn this;\n";
            s ~= "\t}\n";
        }
    }
    if(isArray && !isPrimitiveArray && "Addressable"!=javaType) {
        // Remove the [] at the end so that it is a single Struct type
        javaType = javaType[0..$-2];
    }

    if(isArray && !isPrimitiveArray && "Addressable"==javaType) {
        javaType ~= "[]";
    }

    s ~= "\tpublic %s %s(%s v) {\n".format(structName, v.name, javaType);

    if(isPrimitiveArray) {
        auto arraySize = size(array);
        auto elementSize = size(array.type());
        auto numElements = arraySize / elementSize;
        s ~= "\t\tset(mem, %s, v, %s);\n".format(offset, numElements);
    } else {
        s ~= "\t\tset(mem, %s, v);\n".format(offset);
    }
    s ~= "\t\treturn this;\n";
    s ~= "\t}\n";

    return s;
}
int counter = 0;
string createToString(string name, Var[] vars) {

    const pattern = regex(r"pp(.*)Names");

    int _getCountVarOffset(string capture) {
        import std;
        auto findme = capture.toLower() ~ "count";
        int offset = 0;
        foreach(v; vars) {
            if(v.name.toLower()==findme) {
                return offset;
            }
            offset += size(v.type());
        }
        return -1;
    }

    string _toString() {
        string names;
        string values;
        int offset = 0;

        foreach(i, v; vars) {
            auto javaType = capitalised(getJavaType(v.type(), false));
            auto array = v.type().as!ArrayType;
            bool isArray = array !is null;
            bool isPrimitiveArray = isArray && !array.type().isA!PtrType &&
                (isBuiltin(array.type()) || isEnum(array.type()));
            bool quoted = false;

            if(isArray) {
                javaType = "ArrayOf" ~ javaType[0..$-2];
            }

            if(isPrimitiveArray && array.type().kind == TKind.CHAR && isPossibleString(v.name)) {
                javaType = "String";
                isArray = false;
                quoted = true;
            }

            // Convert these to getString:
            // - XCount
			// - ppXNames
            auto countOffset = 0;
            if(auto capture = v.name.matchFirst(pattern)) {
                if(auto countVar = _getCountVarOffset(capture[1])) {
                    javaType = "ArrayOfString";
                    countOffset = countVar;
                    counter++;
                }
            }

            names ~= "\t\t\t\t\t\"%s=".format(v.name) ~ (quoted ? "'%s'" : "%s");
            values ~= "\t\t\t\tget%s(startMem, offset + %s".format(javaType, offset);

            if("ArrayOfStruct"==javaType) {
                auto arraySize = size(array);
                auto elementSize = size(array.type());
                auto realJavaType = getJavaType(v.type(), true)[0..$-2];
                values ~= ", %s, %s.class)".format(arraySize / elementSize, realJavaType);

            } else if("Struct"==javaType) {
                auto realJavaType = getJavaType(v.type(), true);
                values ~= ", %s.class)".format(realJavaType);

            } else if("ArrayOfString"==javaType) {
                values ~= ", getInt(startMem, offset + %s))".format(countOffset);

            } else if(isArray) {
                auto arraySize = size(array);
                auto elementSize = size(array.type());
                values ~= ", %s)".format(arraySize / elementSize);

            } else {
                values ~= ")";
            }

            offset += size(v.type());
            if(i < vars.length-1) {
                names ~= ", \" +\n";
                values ~= ",\n";
            } else {
                names ~= "}\",\n";
                values ~= ")";
            }
        }
        return names ~ values;
    }

    string _getString() {
        string s;
        if(vars.length==0) {
            s ~= "\"%s{}\"".format(name);
        } else {
            s ~= "String.format(\"%s{\" +\n%s".format(name, _toString());
        }
        return s;
    }

    string s = "\t@Override public String toString() {\n";

    s ~= "\t\tvar s = new StringBuilder();\n";
    s ~= "\t\tvar offset = 0;\n";
    s ~= "\t\tif(count > 1) s.append(\"[\\n\\t\");\n";
    s ~= "\t\tfor(int i=0; i<count; i++) {\n";
    s ~= "\t\t\tif(i>0) s.append(\",\\n\\t\");\n";
    s ~= "\t\t\ts.append(";
    s ~= _getString();
    s ~= ");\n";
    s ~= "\t\t\toffset += LAYOUT.byteSize();\n";
    s ~= "\t\t}\n";
    s ~= "\t\tif(count > 1) s.append(\"\\n]\");\n";

    s ~= "\t\treturn s.toString();\n";
    return s ~ "\t}\n";
}
string getStructureType(string name) {
    import std;

    string st = "VK_STRUCTURE_TYPE";

    // Assume name is camel case
    if(name.startsWith("Vk")) name = name[2..$];

    const keywordsAZ = [
        "ASTC", "HDR", "D3D12", "Win32", "AABB", "Uint8",
        "Int8", "Float16", "Int64", "RGBA10X6"
    ];
    const keywords09 = ["2D", "3D", "8Bit", "16Bit"];

    for(int i=0; i<name.length; ) {
        char peek(int offset) {
            return i+offset >= name.length ? '\0' : name[i+offset];
        }
        bool isKw(string s, int offset) {
            foreach(j; 0..s.length.as!int) {
                if(peek(j+offset)!=s[j]) return false;
            }
            return true;
        }
        bool isUpper(char c) { return c >= 'A' && c <= 'Z'; }
        bool isNumber(char c) { return c >= '0' && c <= '9'; }

        string findAZKeyword() {
            return keywordsAZ.filter!(it=>isKw(it, -1)).frontOrElse!string(null);
        }
        string find09Keyword() {
            return keywords09.filter!(it=>isKw(it, -1)).frontOrElse!string(null);
        }

        auto ch = name[i];

        if(isUpper(ch)) {
            st ~= "_";
            st ~= ch;
            i++;

            if(name[i-1] == 'W' && i+7 < name.length && "Scaling"==name[i..i+7]) {
                // _W_SCALING

            } else if(auto kw = findAZKeyword()) {
                auto count = kw.length-1;
                st ~= name[i..i+count];
                i += count;

            } else if(isUpper(peek(0))) {
                while(isUpper(peek(0))) {
                    st ~= peek(0);
                    i++;
                    if(!isUpper(peek(1)) && peek(1) != 0) {
                        break;
                    }
                }
            }
        } else if(isNumber(ch)) {
            st ~= "_";
            st ~= ch;
            i++;

            if(i>7 && name[i-7..i-1] == "Vulkan") {
                // VULKAN_i_j
                st ~= "_";
                st ~= peek(0);
                i++;

            } else if(auto kw = find09Keyword()) {
                auto count = kw.length-1;
                st ~= name[i..i+count];
                i += count;

            } else if(isNumber(peek(0))) {
                while(isNumber(peek(0))) {
                    st ~= peek(0);
                    i++;
                }
            }
        } else {
            i++;
            st ~= ch;
        }
    }

    return st.toUpper();
}